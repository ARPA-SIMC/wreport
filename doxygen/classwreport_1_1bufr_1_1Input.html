<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libwreport: wreport::bufr::Input Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libwreport
   &#160;<span id="projectnumber">3.23</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacewreport.html">wreport</a></li><li class="navelem"><b>bufr</b></li><li class="navelem"><a class="el" href="classwreport_1_1bufr_1_1Input.html">Input</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">wreport::bufr::Input Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Binary buffer with bit-level read operations.  
 <a href="classwreport_1_1bufr_1_1Input.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="input_8h_source.html">input.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02d77e80d3a7242187b3e811e606cbea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a02d77e80d3a7242187b3e811e606cbea">Input</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a02d77e80d3a7242187b3e811e606cbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a string iinto a <a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a>.  <a href="#a02d77e80d3a7242187b3e811e606cbea">More...</a><br /></td></tr>
<tr class="separator:a02d77e80d3a7242187b3e811e606cbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4376caab89e388d1765bb4b3dff02e13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a4376caab89e388d1765bb4b3dff02e13">scan_lead_sections</a> ()</td></tr>
<tr class="memdesc:a4376caab89e388d1765bb4b3dff02e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the message filling in the sec[] array of start offsets of sections 0 and 1.  <a href="#a4376caab89e388d1765bb4b3dff02e13">More...</a><br /></td></tr>
<tr class="separator:a4376caab89e388d1765bb4b3dff02e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f271fa8bed65385372afce0f18fc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a35f271fa8bed65385372afce0f18fc50">scan_other_sections</a> (bool has_optional)</td></tr>
<tr class="memdesc:a35f271fa8bed65385372afce0f18fc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan the message filling in the sec[] array of section start offsets of all sections from 2 on.  <a href="#a35f271fa8bed65385372afce0f18fc50">More...</a><br /></td></tr>
<tr class="separator:a35f271fa8bed65385372afce0f18fc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5103447829ba96ebfb8189c0289e1a6d"><td class="memItemLeft" align="right" valign="top"><a id="a5103447829ba96ebfb8189c0289e1a6d"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a5103447829ba96ebfb8189c0289e1a6d">offset</a> () const</td></tr>
<tr class="memdesc:a5103447829ba96ebfb8189c0289e1a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current decoding byte offset. <br /></td></tr>
<tr class="separator:a5103447829ba96ebfb8189c0289e1a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bab0852bc06e8047c9b740c43178a66"><td class="memItemLeft" align="right" valign="top"><a id="a3bab0852bc06e8047c9b740c43178a66"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a3bab0852bc06e8047c9b740c43178a66">bits_left</a> () const</td></tr>
<tr class="memdesc:a3bab0852bc06e8047c9b740c43178a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bits left in the message to be decoded. <br /></td></tr>
<tr class="separator:a3bab0852bc06e8047c9b740c43178a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0141b370f13c39798b64f134339b26db"><td class="memItemLeft" align="right" valign="top"><a id="a0141b370f13c39798b64f134339b26db"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a0141b370f13c39798b64f134339b26db">read_byte</a> (unsigned pos) const</td></tr>
<tr class="memdesc:a0141b370f13c39798b64f134339b26db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte value at offset <em>pos</em>. <br /></td></tr>
<tr class="separator:a0141b370f13c39798b64f134339b26db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06d02c33a356e630f27345dbba04065"><td class="memItemLeft" align="right" valign="top"><a id="ab06d02c33a356e630f27345dbba04065"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ab06d02c33a356e630f27345dbba04065">read_byte</a> (unsigned section, unsigned pos) const</td></tr>
<tr class="memdesc:ab06d02c33a356e630f27345dbba04065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte value at offset <em>pos</em> inside section <em>section</em>. <br /></td></tr>
<tr class="separator:ab06d02c33a356e630f27345dbba04065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2ca1327633f165d30029cc483e0a91"><td class="memItemLeft" align="right" valign="top"><a id="a6c2ca1327633f165d30029cc483e0a91"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a6c2ca1327633f165d30029cc483e0a91">read_number</a> (unsigned pos, unsigned byte_len) const</td></tr>
<tr class="memdesc:a6c2ca1327633f165d30029cc483e0a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a big endian integer value <em>byte_len</em> bytes long, at offset <em>pos</em>. <br /></td></tr>
<tr class="separator:a6c2ca1327633f165d30029cc483e0a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1155df9abdc8632769c2ad4346ce2d7"><td class="memItemLeft" align="right" valign="top"><a id="ab1155df9abdc8632769c2ad4346ce2d7"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ab1155df9abdc8632769c2ad4346ce2d7">read_number</a> (unsigned section, unsigned pos, unsigned byte_len) const</td></tr>
<tr class="memdesc:ab1155df9abdc8632769c2ad4346ce2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a big endian integer value <em>byte_len</em> bytes long, at offset <em>pos</em> inside section <em>section</em>. <br /></td></tr>
<tr class="separator:ab1155df9abdc8632769c2ad4346ce2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b5ffc6565fe71f84beb253292fffd"><td class="memItemLeft" align="right" valign="top"><a id="a084b5ffc6565fe71f84beb253292fffd"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a084b5ffc6565fe71f84beb253292fffd">get_bits</a> (unsigned n)</td></tr>
<tr class="memdesc:a084b5ffc6565fe71f84beb253292fffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the integer value of the next 'n' bits from the decode input n must be &lt;= 32. <br /></td></tr>
<tr class="separator:a084b5ffc6565fe71f84beb253292fffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8125276c4f78978df037a7c08ecfb671"><td class="memItemLeft" align="right" valign="top"><a id="a8125276c4f78978df037a7c08ecfb671"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a8125276c4f78978df037a7c08ecfb671">debug_dump_next_bits</a> (const char *desc, int count) const</td></tr>
<tr class="memdesc:a8125276c4f78978df037a7c08ecfb671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump to stderr 'count' bits of 'buf', starting at the 'ofs-th' bit. <br /></td></tr>
<tr class="separator:a8125276c4f78978df037a7c08ecfb671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed245cbda1fc9483c26a5f75b9e81c69"><td class="memItemLeft" align="right" valign="top"><a id="aed245cbda1fc9483c26a5f75b9e81c69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#aed245cbda1fc9483c26a5f75b9e81c69">parse_error</a> (const char *fmt,...) const <a class="el" href="error_8h.html#ac90261814c6621766ebec4d00df9f794">WREPORT_THROWF_ATTRS</a>(2</td></tr>
<tr class="memdesc:aed245cbda1fc9483c26a5f75b9e81c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> at the current decoding location. <br /></td></tr>
<tr class="separator:aed245cbda1fc9483c26a5f75b9e81c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e2c4ff99eda3588d5ffd0eda826c77"><td class="memItemLeft" align="right" valign="top"><a id="a53e2c4ff99eda3588d5ffd0eda826c77"></a>
void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a53e2c4ff99eda3588d5ffd0eda826c77">parse_error</a> (unsigned pos, const char *fmt,...) const <a class="el" href="error_8h.html#ac90261814c6621766ebec4d00df9f794">WREPORT_THROWF_ATTRS</a>(3</td></tr>
<tr class="memdesc:a53e2c4ff99eda3588d5ffd0eda826c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> at the given decoding location. <br /></td></tr>
<tr class="separator:a53e2c4ff99eda3588d5ffd0eda826c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e45cd01ff7fde54db1c1e6a2c01b3e9"><td class="memItemLeft" align="right" valign="top"><a id="a8e45cd01ff7fde54db1c1e6a2c01b3e9"></a>
void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a8e45cd01ff7fde54db1c1e6a2c01b3e9">parse_error</a> (unsigned section, unsigned pos, const char *fmt,...) const <a class="el" href="error_8h.html#ac90261814c6621766ebec4d00df9f794">WREPORT_THROWF_ATTRS</a>(4</td></tr>
<tr class="memdesc:a8e45cd01ff7fde54db1c1e6a2c01b3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> at the given decoding location inside the given section. <br /></td></tr>
<tr class="separator:a8e45cd01ff7fde54db1c1e6a2c01b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630824dfc420b10e2d02b59b4df12291"><td class="memItemLeft" align="right" valign="top">void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a630824dfc420b10e2d02b59b4df12291">check_available_data</a> (unsigned pos, size_t datalen, const char *expected)</td></tr>
<tr class="memdesc:a630824dfc420b10e2d02b59b4df12291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise.  <a href="#a630824dfc420b10e2d02b59b4df12291">More...</a><br /></td></tr>
<tr class="separator:a630824dfc420b10e2d02b59b4df12291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa248a75a9a9a4e7db728178b9057897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#aaa248a75a9a9a4e7db728178b9057897">check_available_message_data</a> (unsigned section, unsigned pos, size_t datalen, const char *expected)</td></tr>
<tr class="memdesc:aaa248a75a9a9a4e7db728178b9057897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em> in section <em>section</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise.  <a href="#aaa248a75a9a9a4e7db728178b9057897">More...</a><br /></td></tr>
<tr class="separator:aaa248a75a9a9a4e7db728178b9057897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2c2bdda1c4397e2f05a9d0f9462970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a0b2c2bdda1c4397e2f05a9d0f9462970">check_available_section_data</a> (unsigned section, unsigned pos, size_t datalen, const char *expected)</td></tr>
<tr class="memdesc:a0b2c2bdda1c4397e2f05a9d0f9462970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the given section in the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise.  <a href="#a0b2c2bdda1c4397e2f05a9d0f9462970">More...</a><br /></td></tr>
<tr class="separator:a0b2c2bdda1c4397e2f05a9d0f9462970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c16676c09af01660fd5bd30940063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a0f7c16676c09af01660fd5bd30940063">decode_compressed_number</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest, uint32_t base, unsigned diffbits)</td></tr>
<tr class="memdesc:a0f7c16676c09af01660fd5bd30940063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a compressed number as described by dest.info(), ad set it as value for <em>dest</em>.  <a href="#a0f7c16676c09af01660fd5bd30940063">More...</a><br /></td></tr>
<tr class="separator:a0f7c16676c09af01660fd5bd30940063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19ed91318abdb9a7e4807b7f5d0a623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#af19ed91318abdb9a7e4807b7f5d0a623">decode_number</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest)</td></tr>
<tr class="memdesc:af19ed91318abdb9a7e4807b7f5d0a623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a number as described by dest.info(), and set it as value for <em>dest</em>.  <a href="#af19ed91318abdb9a7e4807b7f5d0a623">More...</a><br /></td></tr>
<tr class="separator:af19ed91318abdb9a7e4807b7f5d0a623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2533b8a5bad2a09c6f2dc6b19532488"><td class="memItemLeft" align="right" valign="top"><a id="ad2533b8a5bad2a09c6f2dc6b19532488"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>decode_compressed_base</b> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, uint32_t &amp;base, uint32_t &amp;diffbits)</td></tr>
<tr class="separator:ad2533b8a5bad2a09c6f2dc6b19532488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c51eea6c1940e396115d5f3eba1c90"><td class="memItemLeft" align="right" valign="top"><a id="a00c51eea6c1940e396115d5f3eba1c90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a00c51eea6c1940e396115d5f3eba1c90">decode_compressed_number</a> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, unsigned subsets, std::function&lt; void(unsigned, <a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&amp;)&gt; dest)</td></tr>
<tr class="memdesc:a00c51eea6c1940e396115d5f3eba1c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a number as described by <em>info</em> from a compressed bufr with <em>subsets</em> subsets, and send the resulting variables to <em>dest</em>. <br /></td></tr>
<tr class="separator:a00c51eea6c1940e396115d5f3eba1c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cb44a1bb13a82ffd0fd5f176434c82"><td class="memItemLeft" align="right" valign="top"><a id="a67cb44a1bb13a82ffd0fd5f176434c82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>decode_string</b> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, unsigned subsets, <a class="el" href="structwreport_1_1bufr_1_1DispatchToSubsets.html">DispatchToSubsets</a> &amp;dest)</td></tr>
<tr class="separator:a67cb44a1bb13a82ffd0fd5f176434c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8279b1957f49ff6a7ea72180aec87599"><td class="memItemLeft" align="right" valign="top"><a id="a8279b1957f49ff6a7ea72180aec87599"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>decode_compressed_number</b> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, unsigned subsets, <a class="el" href="structwreport_1_1bufr_1_1DispatchToSubsets.html">DispatchToSubsets</a> &amp;dest)</td></tr>
<tr class="separator:a8279b1957f49ff6a7ea72180aec87599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a04e07dad0e549625d0e7a5c97a9352"><td class="memItemLeft" align="right" valign="top"><a id="a8a04e07dad0e549625d0e7a5c97a9352"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a8a04e07dad0e549625d0e7a5c97a9352">decode_compressed_number</a> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, const <a class="el" href="structwreport_1_1bulletin_1_1AssociatedField.html">bulletin::AssociatedField</a> &amp;afield, unsigned subsets, std::function&lt; void(unsigned, <a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&amp;)&gt; dest)</td></tr>
<tr class="memdesc:a8a04e07dad0e549625d0e7a5c97a9352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a number as described by <em>info</em> from a compressed bufr with <em>subsets</em> subsets, and send the resulting variables to <em>dest</em>. <br /></td></tr>
<tr class="separator:a8a04e07dad0e549625d0e7a5c97a9352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe80fdac8e1c6f021620220e49117b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#adfe80fdac8e1c6f021620220e49117b2">decode_compressed_semantic_number</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest, unsigned subsets)</td></tr>
<tr class="memdesc:adfe80fdac8e1c6f021620220e49117b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a number as described by dest.info(), and set it as value for <em>dest</em>.  <a href="#adfe80fdac8e1c6f021620220e49117b2">More...</a><br /></td></tr>
<tr class="separator:adfe80fdac8e1c6f021620220e49117b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffddb7ab2fb2c10253d9bce2330088d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#adffddb7ab2fb2c10253d9bce2330088d">decode_string</a> (unsigned bit_len, char *str, size_t &amp;len)</td></tr>
<tr class="memdesc:adffddb7ab2fb2c10253d9bce2330088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string from the data section.  <a href="#adffddb7ab2fb2c10253d9bce2330088d">More...</a><br /></td></tr>
<tr class="separator:adffddb7ab2fb2c10253d9bce2330088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71969033f3af516e770d52c4a283c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ab71969033f3af516e770d52c4a283c4d">decode_string</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest)</td></tr>
<tr class="memdesc:ab71969033f3af516e770d52c4a283c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string as described by dest.info(), ad set it as value for <em>dest</em>.  <a href="#ab71969033f3af516e770d52c4a283c4d">More...</a><br /></td></tr>
<tr class="separator:ab71969033f3af516e770d52c4a283c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dce8ed4145dc476f2fba88bc8e7d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a46dce8ed4145dc476f2fba88bc8e7d2e">decode_string</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest, unsigned subsets)</td></tr>
<tr class="memdesc:a46dce8ed4145dc476f2fba88bc8e7d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string as described by dest.info(), and set it as value for <em>dest</em>.  <a href="#a46dce8ed4145dc476f2fba88bc8e7d2e">More...</a><br /></td></tr>
<tr class="separator:a46dce8ed4145dc476f2fba88bc8e7d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1278b7fc6d5f60ec239f39038a3ebb98"><td class="memItemLeft" align="right" valign="top"><a id="a1278b7fc6d5f60ec239f39038a3ebb98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a1278b7fc6d5f60ec239f39038a3ebb98">decode_string</a> (<a class="el" href="namespacewreport.html#ab56051168442bfb0c18ef00affeb525a">Varinfo</a> info, unsigned subsets, std::function&lt; void(unsigned, <a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&amp;)&gt; dest)</td></tr>
<tr class="memdesc:a1278b7fc6d5f60ec239f39038a3ebb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string as described by <em>info</em> from a compressed bufr with <em>subsets</em> subsets, and send the resulting variables to <em>dest</em>. <br /></td></tr>
<tr class="separator:a1278b7fc6d5f60ec239f39038a3ebb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca78db11b47f1a91f88bcdfe741a5d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#aca78db11b47f1a91f88bcdfe741a5d6a">decode_binary</a> (<a class="el" href="classwreport_1_1Var.html">Var</a> &amp;dest)</td></tr>
<tr class="memdesc:aca78db11b47f1a91f88bcdfe741a5d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a generic binary value as-is, as described by dest.info(), ad set it as value for <em>dest</em>.  <a href="#aca78db11b47f1a91f88bcdfe741a5d6a">More...</a><br /></td></tr>
<tr class="separator:aca78db11b47f1a91f88bcdfe741a5d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d50db706296ab78479e8942b186b11b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a2d50db706296ab78479e8942b186b11b">decode_uncompressed_bitmap</a> (unsigned size)</td></tr>
<tr class="memdesc:a2d50db706296ab78479e8942b186b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode an uncompressed bitmap of <em>size</em> bits.  <a href="#a2d50db706296ab78479e8942b186b11b">More...</a><br /></td></tr>
<tr class="separator:a2d50db706296ab78479e8942b186b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8917b571fbe486038a4800025e3542"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ada8917b571fbe486038a4800025e3542">decode_compressed_bitmap</a> (unsigned size)</td></tr>
<tr class="memdesc:ada8917b571fbe486038a4800025e3542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a "compressed" bitmap of <em>size</em> bits.  <a href="#ada8917b571fbe486038a4800025e3542">More...</a><br /></td></tr>
<tr class="separator:ada8917b571fbe486038a4800025e3542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ab5fd948d3929f98d32d305ec18dae04f"><td class="memItemLeft" align="right" valign="top"><a id="ab5fd948d3929f98d32d305ec18dae04f"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ab5fd948d3929f98d32d305ec18dae04f">data</a></td></tr>
<tr class="memdesc:ab5fd948d3929f98d32d305ec18dae04f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a> buffer. <br /></td></tr>
<tr class="separator:ab5fd948d3929f98d32d305ec18dae04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003b7fb62bcbb00f41add54d579c85fb"><td class="memItemLeft" align="right" valign="top"><a id="a003b7fb62bcbb00f41add54d579c85fb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a003b7fb62bcbb00f41add54d579c85fb">data_len</a></td></tr>
<tr class="memdesc:a003b7fb62bcbb00f41add54d579c85fb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a> buffer size. <br /></td></tr>
<tr class="separator:a003b7fb62bcbb00f41add54d579c85fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e3046129f5dc9410893079f18c62e1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ac2e3046129f5dc9410893079f18c62e1">fname</a> = nullptr</td></tr>
<tr class="memdesc:ac2e3046129f5dc9410893079f18c62e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a> file name (optional).  <a href="#ac2e3046129f5dc9410893079f18c62e1">More...</a><br /></td></tr>
<tr class="separator:ac2e3046129f5dc9410893079f18c62e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d49b2d39c203f1795e2c03a73df0e6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#aa6d49b2d39c203f1795e2c03a73df0e6">start_offset</a> = 0</td></tr>
<tr class="memdesc:aa6d49b2d39c203f1795e2c03a73df0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">File offset of the start of the message.  <a href="#aa6d49b2d39c203f1795e2c03a73df0e6">More...</a><br /></td></tr>
<tr class="separator:aa6d49b2d39c203f1795e2c03a73df0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5267955e6cdcafd7e1dfa28a5c8ea7fd"><td class="memItemLeft" align="right" valign="top"><a id="a5267955e6cdcafd7e1dfa28a5c8ea7fd"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a5267955e6cdcafd7e1dfa28a5c8ea7fd">s4_cursor</a> = 0</td></tr>
<tr class="memdesc:a5267955e6cdcafd7e1dfa28a5c8ea7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset of the byte we are currently decoding. <br /></td></tr>
<tr class="separator:a5267955e6cdcafd7e1dfa28a5c8ea7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b11501818f480ab861ed8ff40b780d7"><td class="memItemLeft" align="right" valign="top"><a id="a2b11501818f480ab861ed8ff40b780d7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a2b11501818f480ab861ed8ff40b780d7">pbyte</a> = 0</td></tr>
<tr class="memdesc:a2b11501818f480ab861ed8ff40b780d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte we are currently decoding. <br /></td></tr>
<tr class="separator:a2b11501818f480ab861ed8ff40b780d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95cf41cfab873f0e29d20054b55d435"><td class="memItemLeft" align="right" valign="top"><a id="ae95cf41cfab873f0e29d20054b55d435"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#ae95cf41cfab873f0e29d20054b55d435">pbyte_len</a> = 0</td></tr>
<tr class="memdesc:ae95cf41cfab873f0e29d20054b55d435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits left in pbyte to decode. <br /></td></tr>
<tr class="separator:ae95cf41cfab873f0e29d20054b55d435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47e25b4ecc97ac1241d16733aa0fa62"><td class="memItemLeft" align="right" valign="top"><a id="aa47e25b4ecc97ac1241d16733aa0fa62"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#aa47e25b4ecc97ac1241d16733aa0fa62">sec</a> [6]</td></tr>
<tr class="memdesc:aa47e25b4ecc97ac1241d16733aa0fa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets of the start of BUFR sections. <br /></td></tr>
<tr class="separator:aa47e25b4ecc97ac1241d16733aa0fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b5c74e63425ee69df9e0f4f4fb81784"><td class="memItemLeft" align="right" valign="top"><a id="a4b5c74e63425ee69df9e0f4f4fb81784"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwreport_1_1bufr_1_1Input.html#a4b5c74e63425ee69df9e0f4f4fb81784">scan_section_length</a> (unsigned sec_no)</td></tr>
<tr class="memdesc:a4b5c74e63425ee69df9e0f4f4fb81784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan length of section <em>sec_no</em>, filling in the start of the next section in sec[sec_no + 1]. <br /></td></tr>
<tr class="separator:a4b5c74e63425ee69df9e0f4f4fb81784"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Binary buffer with bit-level read operations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a02d77e80d3a7242187b3e811e606cbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d77e80d3a7242187b3e811e606cbea">&#9670;&nbsp;</a></span>Input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wreport::bufr::Input::Input </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a string iinto a <a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>String with the data to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a630824dfc420b10e2d02b59b4df12291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630824dfc420b10e2d02b59b4df12291">&#9670;&nbsp;</a></span>check_available_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void wreport::bufr::Input::check_available_data </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Starting offset of the required data </td></tr>
    <tr><td class="paramname">datalen</td><td>Required amount of data expected starting from <em>pos</em> </td></tr>
    <tr><td class="paramname">expected</td><td>name of what we are about to decode, used for generating nice error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa248a75a9a9a4e7db728178b9057897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa248a75a9a9a4e7db728178b9057897">&#9670;&nbsp;</a></span>check_available_message_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::check_available_message_data </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em> in section <em>section</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>Number of the section to check </td></tr>
    <tr><td class="paramname">pos</td><td>Starting offset inside the section of the required data </td></tr>
    <tr><td class="paramname">datalen</td><td>Required amount of data expected starting from <em>pos</em> </td></tr>
    <tr><td class="paramname">expected</td><td>Name of what we are about to decode, used for generating nice error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b2c2bdda1c4397e2f05a9d0f9462970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2c2bdda1c4397e2f05a9d0f9462970">&#9670;&nbsp;</a></span>check_available_section_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::check_available_section_data </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datalen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the given section in the input buffer contains at least <em>datalen</em> characters after offset <em>pos</em>; throw <a class="el" href="classwreport_1_1error__parse.html" title="Report an error when parsing informations. ">error_parse</a> otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">section</td><td>Number of the section to check </td></tr>
    <tr><td class="paramname">pos</td><td>Starting offset inside the section of the required data </td></tr>
    <tr><td class="paramname">datalen</td><td>Required amount of data expected starting from <em>pos</em> </td></tr>
    <tr><td class="paramname">expected</td><td>Name of what we are about to decode, used for generating nice error messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca78db11b47f1a91f88bcdfe741a5d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca78db11b47f1a91f88bcdfe741a5d6a">&#9670;&nbsp;</a></span>decode_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a generic binary value as-is, as described by dest.info(), ad set it as value for <em>dest</em>. </p>
<p>It is assumed that <em>dest</em> is not set, therefore in case we decode a missing value, <em>dest</em> will not be touched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada8917b571fbe486038a4800025e3542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8917b571fbe486038a4800025e3542">&#9670;&nbsp;</a></span>decode_compressed_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wreport::bufr::Input::decode_compressed_bitmap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a "compressed" bitmap of <em>size</em> bits. </p>
<p>The result will be a string <em>size</em> bytes long, with a '+' where the bitmap reports that data is present, and a '-' where the bitmap reports that data is not present.</p>
<p>It would be more correct to say that it decodes a bitmap from a compressed BUFR message, because bitmaps in compressed messages are actually encoded with 7 bits per bit instead of one, because after each bit they need to send 6 bits saying that it will be followed by 0 bits of difference values. </p>

</div>
</div>
<a id="a0f7c16676c09af01660fd5bd30940063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7c16676c09af01660fd5bd30940063">&#9670;&nbsp;</a></span>decode_compressed_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_compressed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>diffbits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a compressed number as described by dest.info(), ad set it as value for <em>dest</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
    <tr><td class="paramname">base</td><td>The base value for the compressed number </td></tr>
    <tr><td class="paramname">diffbits</td><td>The number of bits used to encode the difference from <em>base</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfe80fdac8e1c6f021620220e49117b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe80fdac8e1c6f021620220e49117b2">&#9670;&nbsp;</a></span>decode_compressed_semantic_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_compressed_semantic_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a number as described by dest.info(), and set it as value for <em>dest</em>. </p>
<p>The number is decoded for <em>subsets</em> compressed datasets, and an exception is thrown if the values differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
    <tr><td class="paramname">subsets</td><td>Number of subsets in the compressed data section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19ed91318abdb9a7e4807b7f5d0a623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19ed91318abdb9a7e4807b7f5d0a623">&#9670;&nbsp;</a></span>decode_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a number as described by dest.info(), and set it as value for <em>dest</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adffddb7ab2fb2c10253d9bce2330088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffddb7ab2fb2c10253d9bce2330088d">&#9670;&nbsp;</a></span>decode_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wreport::bufr::Input::decode_string </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bit_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string from the data section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bit_len</td><td>Number of bits (not bytes) to read. It is normally a multiple of 8, and when it is not, the last character will contain the partial byte read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>Buffer where the string is written. Must be big enough to contain the longest string described by info, plus 2 bytes </td></tr>
    <tr><td class="paramname">len</td><td>The string length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we decoded a real string, false if we decoded a missing string value </dd></dl>

</div>
</div>
<a id="ab71969033f3af516e770d52c4a283c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71969033f3af516e770d52c4a283c4d">&#9670;&nbsp;</a></span>decode_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string as described by dest.info(), ad set it as value for <em>dest</em>. </p>
<p>It is assumed that <em>dest</em> is not set, therefore in case we decode a missing value, <em>dest</em> will not be touched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46dce8ed4145dc476f2fba88bc8e7d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dce8ed4145dc476f2fba88bc8e7d2e">&#9670;&nbsp;</a></span>decode_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::decode_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwreport_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string as described by dest.info(), and set it as value for <em>dest</em>. </p>
<p>The string is decoded for <em>subsets</em> compressed datasets, and an exception is thrown if the values differ.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>Variable which holds the decoding information and that will hold the decoded value </td></tr>
    <tr><td class="paramname">subsets</td><td>Number of subsets in the compressed data section </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d50db706296ab78479e8942b186b11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d50db706296ab78479e8942b186b11b">&#9670;&nbsp;</a></span>decode_uncompressed_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string wreport::bufr::Input::decode_uncompressed_bitmap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode an uncompressed bitmap of <em>size</em> bits. </p>
<p>The result will be a string <em>size</em> bytes long, with a '+' where the bitmap reports that data is present, and a '-' where the bitmap reports that data is not present. </p>

</div>
</div>
<a id="a4376caab89e388d1765bb4b3dff02e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4376caab89e388d1765bb4b3dff02e13">&#9670;&nbsp;</a></span>scan_lead_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::scan_lead_sections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan the message filling in the sec[] array of start offsets of sections 0 and 1. </p>
<p>We cannot scan past section 1 until we decode it, because we need to know if section 2 is present or not </p>

</div>
</div>
<a id="a35f271fa8bed65385372afce0f18fc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f271fa8bed65385372afce0f18fc50">&#9670;&nbsp;</a></span>scan_other_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wreport::bufr::Input::scan_other_sections </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_optional</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan the message filling in the sec[] array of section start offsets of all sections from 2 on. </p>
<p>It also initialises points s4_cursor to the begin of the data in section 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">has_optional</td><td>True if the optional section is present, false if it should be skipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ac2e3046129f5dc9410893079f18c62e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e3046129f5dc9410893079f18c62e1">&#9670;&nbsp;</a></span>fname</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* wreport::bufr::Input::fname = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classwreport_1_1bufr_1_1Input.html" title="Binary buffer with bit-level read operations. ">Input</a> file name (optional). </p>
<p>If available, it will be used to generate better error messages.</p>
<p>If not available, it is NULL. </p>

</div>
</div>
<a id="aa6d49b2d39c203f1795e2c03a73df0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d49b2d39c203f1795e2c03a73df0e6">&#9670;&nbsp;</a></span>start_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t wreport::bufr::Input::start_offset = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File offset of the start of the message. </p>
<p>If available, it will be used to generate better error messages.</p>
<p>If not available, it is 0. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="input_8h_source.html">input.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 11 2019 14:50:35 for libwreport by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
